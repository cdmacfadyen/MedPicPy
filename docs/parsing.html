<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>medpicpy.parsing API documentation</title>
<meta name="description" content="medpicpy&#39;s higher level functions to abstract over reading
in medical imaging data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>medpicpy.parsing</code></h1>
</header>
<section id="section-intro">
<p>medpicpy's higher level functions to abstract over reading
in medical imaging data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;medpicpy&#39;s higher level functions to abstract over reading 
in medical imaging data

&#34;&#34;&#34;
import glob
from pathlib import Path
from os.path import normpath

import pandas as pd
import numpy as np
import cv2
import logging

from . import io
from .utils import remove_sub_paths
from . import config

logging.getLogger(__name__)

def load_images_from_csv(dataframe, 
image_name_column, 
image_dir_path, 
output_shape,
use_memory_mapping=False):
    &#34;&#34;&#34;Read in an array of images from paths specified in a csv

    ##Example
    ```python
    import medpicpy as med
    import pandas as pd

    description = pd.read_csv(&#34;data.csv&#34;) 
    array = med.load_images_from_csv(description, 0, &#34;mini-MIAS/&#34;, (224, 224))
    ```
    Args:
        dataframe (pandas.DataFrame): A pandas dataframe from the csv
        image_name_column (index): Index of column with image names
        image_dir_path (string): Path to directory containing images
        output_shape (tuple): Output shape for each image
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False

    Returns:
        np.Array: Array of images in order 
    &#34;&#34;&#34;
    image_names = dataframe[image_name_column]
    image_paths = image_names.apply(lambda x : image_dir_path + &#34;/&#34; + x)
    image_paths = image_paths.apply(lambda x : normpath(x))

    images = load_images_from_paths(image_paths, output_shape, use_memory_mapping=use_memory_mapping)
    return images

    
def load_bounding_boxes_from_csv(
    dataframe, 
    centre_x_column, 
    centre_y_column, 
    width_column, 
    height_column, 
    x_scale_factor=1,
    y_scale_factor=1
    ): # for bounding boxes need to know if measurements are in pixels or mm
    &#34;&#34;&#34;Read bounding boxes from dataframe of csv

    ##Example
    ```python
    import medpicpy as med
    import pandas as pd

    description = pd.read_csv(&#34;data.csv&#34;) 

    # x and y scale factor are new_image_size / original_image_size
    # only set if the images were resized when being loaded in
    x_scale_factor = 224 / 1024
    y_scale_factor = 224 / 1024

    xs, ys, widths, heights = med.load_bounding_boxes_from_csv(
        description, 
        4, 
        5, 
        6, 
        6, 
        x_scale_factor=x_scale_factor, 
        y_scale_factor=y_scale_factor
    )

    ```
    Args:
        dataframe (pandas.DataFrame): Dataframe of csv
        centre_x_column (index): Index of column for x anchor or box
        centre_y_column (index): Index of column for y anchor of box
        width_column (index): Index of column for width of box
        height_column (index): Index of column for heigh of box.
            Can be same as width column for squares or circles.
        x_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.
        y_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.

    Returns:
        tuple: 4 tuple of np.Arrays with x, y, widths and heights
    &#34;&#34;&#34;
    bbox_xs = dataframe[centre_x_column]
    bbox_xs = bbox_xs.multiply(x_scale_factor)
    xs_array = bbox_xs.to_numpy(dtype=np.float16)

    bbox_ys = dataframe[centre_y_column]
    bbox_ys = bbox_ys.multiply(y_scale_factor)
    ys_array = bbox_ys.to_numpy(dtype=np.float16)


    bbox_widths = dataframe[width_column]
    bbox_widths = bbox_widths.multiply(x_scale_factor)
    widths_array = bbox_widths.to_numpy(dtype=np.float16)

    bbox_heights = dataframe[height_column]
    bbox_heights = bbox_heights.multiply(y_scale_factor)
    heights_array = bbox_heights.to_numpy(dtype=np.float16)

    array_tuple = (xs_array, ys_array, widths_array, heights_array)

    return array_tuple

# To read datasets where the class name is in the directory structure.
# i.e. covid/im001 or no-covid/im001
# pulls the class names from the path and reads in the images
# as a numpy array
# TODO: make this work for 3D images, either make a new function or 
# add optional args (would be slice axis and slices to take)
def load_classes_in_directory_name(directory, 
    image_extension, 
    output_shape, 
    class_level=1,
    slices_to_take=None,
    slice_axis=-2,
    use_memory_mapping=False):
    &#34;&#34;&#34;Parse datasets where the class name is in the 
    directory structure

    Use this when the class name is one of the directory names
    in the dataset structure. 
    ## Example
    If dataset has directory structure:
    ```
    dataset/
        benign/
            im001.dcm
            im002.dcm
        malignant/
            im001.dcm
            im002.dcm
    ```
    then:
    ```python
        import medpicpy as med
        
        classes, images = med.load_classes_in_directory_name(
            &#34;dataset/&#34;,
            &#34;.dcm&#34;,
            &#34;(128, 128)&#34;
        )
        print(classes)
        # [&#34;benign&#34;, &#34;benign&#34;, &#34;malignant&#34;, &#34;malignant&#34;]
        print(images.shape)
        # (4, 128, 128)
    ```
    Args:
        directory (path): root directory of dataset
        image_extension (str): Wildcard for identifying images,
             e.g for png&#39;s - *.png
        output_shape (tuple): Desired output shape of images
        class_level (int, optional): Which level of directory structure 
            contains class name. Defaults to 1.
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        list(str), np.Array : list of classes and corresponding images with correct shape
    &#34;&#34;&#34;
    path_to_search = directory + &#34;/**/*&#34; + image_extension
    files = glob.glob(path_to_search, recursive=True)
    files = remove_sub_paths(files)
    number_of_files = len(files)
    array_shape = (number_of_files,) + output_shape
    array = io.allocate_array(array_shape, use_memory_mapping=use_memory_mapping)
    classes = np.empty(number_of_files, dtype=object)

    for index, name in enumerate(files):
        parts = Path(name).parts
        class_name = parts[class_level]

        image = io.load_image(name, use_memory_mapping=use_memory_mapping)
        result = cv2.resize(image, output_shape)

        classes[index] = class_name
        array[index] = result
        
    return classes, array



def load_images_from_paths(paths, output_shape, use_memory_mapping=False):
    &#34;&#34;&#34;2D image loading function that takes an array of 
    paths and an output shape and returns the images in 
    the same order as the paths. Requires every 
    path to have an image and every image to be resizeable 
    to the given output shape.

    For higher dimension images use load_series_from_paths.

    Args:
        paths (list or array-like): paths of images to load
        output_shape (tuple): desired shape of each image
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        np.array: all images in numpy format with given shape
    &#34;&#34;&#34;
    array_length = len(paths)
    array_shape = (array_length,) + output_shape # concat tuples to get shape
    image_array = io.allocate_array(array_shape, use_memory_mapping=use_memory_mapping)

    for i in range(0, array_length):
        print(&#34;Loading images {} / {}&#34;.format(i + 1, len(paths)), end=&#34;\r&#34;, flush=True)
        image_name = paths[i]
        image = io.load_image(image_name, use_memory_mapping=use_memory_mapping)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized
    print(&#34;&#34;)
    return image_array

# slice axis will be -2 for most things since they 
# are 1 channel, for colour images would probably be -3
# But I don&#39;t think you get colour 3D scans
# It would work for multimodal things stacked on top of each other though
def load_series_from_paths(
    paths,
    slice_output_shape, 
    slices_to_take,
    slice_axis=-2,
    use_memory_mapping=False
    ):
    &#34;&#34;&#34;Load an array of 3D scans into memory from their paths.

    Useful for e.g. CT or MR scans. Takes a list of paths, the output shape
    for each 2D slice and a list containing which slices 
    to take from each image. To take the first 60 slices
    pass range(0, 60). 

    The output shape should be a tuple of (int, int).
    
    Optionally take which axis to reshape the image along.
    For any scans with one channel (grayscale) slices this should 
    be -2, if there is a colour channel (or its some kind 
    of multimodal stack) then the axis would be -3. 

    ## Example
    If there is dataset with structure:
    ```
    data/
        patient-data.csv
        ID-001/
            SCANS/
                CT/
                    prone.nii.gz
        ID-002/
            SCANS/
                CT/
                    prone.nii.gz
        ID-003/
            SCANS/
                CT/
                    prone.nii.gz
    ```
    then:
    ```python
    import pandas as pd
    import medpicpy as med

    description = pd.read_csv(&#34;data/patient-data.csv&#34;)
    patient_ids = description(&#34;id&#34;)
    filters = [&#34;CT&#34;, &#34;prone&#34;]

    image_paths = med.get_paths_from_ids(
        &#34;data/&#34;,
        patient_ids,
        filters
    )

    print(image_paths)
    # [&#34;data/ID-001/CT/prone.nii.gz&#34;, &#34;data/ID-002/CT/prone.nii.gz&#34;, &#34;data/ID-003/CT/prone.nii.gz&#34;]
    
    slices_to_take = range(60, 120)
    output_slice_shape = (128, 128)    # desired shape of each slice in the scan
    images = med.load_series_from_paths(
        paths, 
        output_slice_shape,
        slices_to_take
        )

    print(images.shape)
    # (3, 60, 128, 128)  
    ```
    
    Args:
        paths (list): list of paths to the scans to load
        slice_output_shape (tuple): shape each slice should be resized to
        slices_to_take (list): list of indices of slices to take
        slice_axis (int, optional): axis to resize along. Defaults to -2.
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        np.array: array of all scans with specified size
    &#34;&#34;&#34;

    output_shape = (len(paths), len(slices_to_take)) + slice_output_shape
    output_array = io.allocate_array(output_shape, use_memory_mapping=use_memory_mapping)
    
    for i in range(0, len(paths)):
        print(&#34;Loading images {} / {}&#34;.format(i + 1, len(paths)), end=&#34;\r&#34;, flush=True)
        path = paths[i]
        image = io.load_image(path, use_memory_mapping=False)
        new_image = io.allocate_array(((len(slices_to_take),) + image[0].shape), use_memory_mapping=False)

        for index, slice_index in enumerate(slices_to_take):
            new_image[index] = image[slice_index]
        
        final_shape = new_image.shape[:slice_axis] + slice_output_shape + new_image.shape[:slice_axis + 2]
        final_image = io.allocate_array(final_shape, use_memory_mapping=use_memory_mapping)

        for j in range(final_shape[0]):
            image = new_image[j][slice_axis]
            image = cv2.resize(image, slice_output_shape)
            final_image[j] = image
        
        output_array[i] = final_image
    print(&#34;&#34;)
    return output_array


def get_length_of_all_series(paths):
    &#34;&#34;&#34;Find the number of 2D slices 
    in a list of images. These images can 
    be 2D, 3D, or a mixture of both. Also 
    returns the paths that each slice comes from, 
    e.g. if an image contains 250 slices, 
    then that path will be duplicated 250 times 
    in the array so the original scan is known. 

    Args:
        paths (list(str)): paths to images

    Returns:
        int, list(str): the total number of slices, and the paths that
        the images come from. 
    &#34;&#34;&#34;
    all_series = []
    for index, path in enumerate(paths):
        if index % 100 == 0:
            print(f&#34;Getting length of images ~ {index} of {len(paths)}&#34;, end=&#34;\r&#34;)
            logging.debug(f&#34;Getting length of images ~ {index} of {len(paths)}&#34;)

        image = io.load_image(path)
        shape = None if image is None else image.shape
        all_series.append(shape)

    print(&#34;finished reading all series&#34;)
    none_count = 0
    for series in all_series:
        if series is None:
            none_count += 1
    print(f&#34;{none_count} out of {len(all_series)} could not be read.&#34;)

    final_paths = []
    series_and_paths = [(series, paths[i]) for i, series in enumerate(all_series) if series is not None]
    all_series = [series for series in all_series if series is not None]
    number_of_series = 0
    for index, series in enumerate(all_series):
        path = series_and_paths[index][1]   # get the path for the image
        if len(series) == 2:  # then it is already 2D
            number_of_series += 1
            final_paths.append(path)
            continue
        elif len(series) == 3: # if its 3d
            if series[0] == 1:        # if its actually 2d
                number_of_series += 1
                final_paths.append(path)
            elif series[2] == 3:
                if not config.suppress_errors:
                    print(&#34;MedPicPy does not currently work with multichannel images&#34;)
                    exit(0)
                    #TODO: change to exception                   
                continue
            else:
                for image in series:
                    number_of_series += 1
                    final_paths.append(path)
        else:
            print(f&#34;Its not 2 or 3D!:{series}&#34;)
            #TODO: change to exception
            exit(0)
    return number_of_series, final_paths
            
def load_all_slices_from_series(paths,
    all_series_length,
    output_shape,
    use_memory_mapping=False):
    &#34;&#34;&#34;Load a dataset of 2D slices from a list 
    of 2 or 3 dimensional scans. Use `get_length_of_all_series`
    to find `all_series_length` if it is not known 
    ahead of time. 

    Args:
        paths (list(str)): list of image paths to load
        all_series_length (int): length of output array
        output_shape (tuple): dimensions to resize each slice to 
        use_memory_mapping (bool, optional): store data on drive instead of ram. Defaults to False.

    Returns:
        np Array: numpy array of resized slices
    &#34;&#34;&#34;
    
    output_array_shape = (all_series_length,) + output_shape
    array = io.allocate_array(output_array_shape, use_memory_mapping=use_memory_mapping)
    images_written = 0
    for image_index, path in enumerate(paths):
        try:
            if images_written == all_series_length:
                print(&#34;Breaking early&#34;)
                break
            if image_index % 100 == 0:
                print(f&#34;Re-loading image: {image_index} of {len(paths)}&#34;, end=&#34;\r&#34;)
                logging.debug(f&#34;Re-loading image: {image_index} of {len(paths)}&#34;)
            
            image = io.load_image(path, use_memory_mapping=use_memory_mapping)
            if image is None:
                continue
            image_shape = image.shape
            if len(image_shape) == 2:
                resized_image = cv2.resize(image, output_shape)
                array[images_written] = resized_image[:]
                images_written += 1
            elif len(image_shape) == 3:

                if image_shape[0] == 1: #its actually 2d
                    resized_image = cv2.resize(image, output_shape)
                    array[images_written] = resized_image[:]
                    images_written += 1
                elif image_shape[2] == 3:
                    continue    #skip rgb
                else:
                    for slice_index in range(len(image)):
                        resized_image = cv2.resize(image[slice_index], output_shape)
                        array[images_written] = resized_image[:]
                        images_written += 1
        except IndexError:
            #TODO: a weird bug, look into why this happens sometimes. 
            if config.suppress_errors:
                logging.debug(f&#34;Suppressing index error in load index for paths:\nAttempted to write to index {images_written}, out of bounds for length {len(array)} on image path {path}&#34;)
            else:
                raise
    return array

def load_specific_slices_from_series(
    paths,
    output_shape,
    slices_to_take,
    use_memory_mapping=False):
    &#34;&#34;&#34;Get specific slice or slices from series of scans.
    Takes path, desired shape and array of slice/slices to 
    take from each series. 

    Args:
        paths (array): array of paths to the series
        output_shape (tuple): desired shape of each slice
        slices_to_take (array of arrays): one array of slices 
            to take for each series
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False

    Returns:
        np.array: every slice as specified by the slices_to_take
    &#34;&#34;&#34; 
    all_series = [io.load_image(path, use_memory_mapping=use_memory_mapping) for path in paths]
    chosen = [[] for series in all_series]

    if len(all_series) is not len(slices_to_take):
        print(&#34;length of series is not the same as slices array&#34;)
        exit(0)
    
    for series in range(0, len(slices_to_take)):
        for slice_index in slices_to_take[series]:
            chosen_slice = all_series[series][slice_index]
            resized_slice = cv2.resize(chosen_slice, output_shape)
            chosen[series].append(resized_slice)
    
    series_lengths = [len(new_series) for new_series in chosen]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape

    array = io.allocate_array(output_array_shape, use_memory_mapping=use_memory_mapping)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = chosen[series_counter][image_counter]
            output_index += 1
    

    return array

def stack_modalities(arrays, axis=-1):
    &#34;&#34;&#34;Turn a list of arrays into one multimodal array.
    
    Creates one array where each element has 
    len(arrays) images. 

    ##Example
    If we have a dataset like:
    ```
    dataset/
        ID-1/
            flair.nii.gz
            t1.nii.gz
        ID-2/
            flair.nii.gz
            t1.nii.gz
    ```
    then:
    ```python
    import medpicpy as med 
    modalities = [[&#34;flair&#34;], [&#34;t1&#34;]]
    paths_for_modality = [med.get_paths_from_ids(
        &#34;dataset/&#34;,
        [&#34;ID-1&#34;, &#34;ID-2&#34;],
        path_filters = modality
    ) for modality in modalities]

    arrays = [med.load_series_from_paths(
        paths,
        (128, 128),
        range(60, 80)
    ) for paths in paths_for_modality]

    multimodal_array = med.stack_modalities(arrays)
    print(multimodal_array.shape)
    # (259, 20, 128, 128, 4)
    ```
    You might want to flatten along the first axis after 
    doing this depending on the dimensionality of the model you are using.
    ```python
    flat_multi_modal = multimodal_array.reshape(-1, *multimodal_array.shape[2:])
    print(&#34;multi modal shape: &#34;, flat_multi_modal.shape)
    # (5180, 128, 128, 4)
    ```
    Args:
        arrays (array): array of arrays of images to stack on 
            top of each other
        axis (int, optional): The axis to stack along, 
            leaving this default is probably fine. Defaults to -1.

    Returns:
        array: the arrays stacked on top of each other
    &#34;&#34;&#34;
    return np.stack(arrays, axis=axis)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="medpicpy.parsing.get_length_of_all_series"><code class="name flex">
<span>def <span class="ident">get_length_of_all_series</span></span>(<span>paths)</span>
</code></dt>
<dd>
<div class="desc"><p>Find the number of 2D slices
in a list of images. These images can
be 2D, 3D, or a mixture of both. Also
returns the paths that each slice comes from,
e.g. if an image contains 250 slices,
then that path will be duplicated 250 times
in the array so the original scan is known. </p>
<h2 id="args">Args</h2>
<p>paths (list(str)): paths to images</p>
<h2 id="returns">Returns</h2>
<p>int, list(str): the total number of slices, and the paths that
the images come from.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_length_of_all_series(paths):
    &#34;&#34;&#34;Find the number of 2D slices 
    in a list of images. These images can 
    be 2D, 3D, or a mixture of both. Also 
    returns the paths that each slice comes from, 
    e.g. if an image contains 250 slices, 
    then that path will be duplicated 250 times 
    in the array so the original scan is known. 

    Args:
        paths (list(str)): paths to images

    Returns:
        int, list(str): the total number of slices, and the paths that
        the images come from. 
    &#34;&#34;&#34;
    all_series = []
    for index, path in enumerate(paths):
        if index % 100 == 0:
            print(f&#34;Getting length of images ~ {index} of {len(paths)}&#34;, end=&#34;\r&#34;)
            logging.debug(f&#34;Getting length of images ~ {index} of {len(paths)}&#34;)

        image = io.load_image(path)
        shape = None if image is None else image.shape
        all_series.append(shape)

    print(&#34;finished reading all series&#34;)
    none_count = 0
    for series in all_series:
        if series is None:
            none_count += 1
    print(f&#34;{none_count} out of {len(all_series)} could not be read.&#34;)

    final_paths = []
    series_and_paths = [(series, paths[i]) for i, series in enumerate(all_series) if series is not None]
    all_series = [series for series in all_series if series is not None]
    number_of_series = 0
    for index, series in enumerate(all_series):
        path = series_and_paths[index][1]   # get the path for the image
        if len(series) == 2:  # then it is already 2D
            number_of_series += 1
            final_paths.append(path)
            continue
        elif len(series) == 3: # if its 3d
            if series[0] == 1:        # if its actually 2d
                number_of_series += 1
                final_paths.append(path)
            elif series[2] == 3:
                if not config.suppress_errors:
                    print(&#34;MedPicPy does not currently work with multichannel images&#34;)
                    exit(0)
                    #TODO: change to exception                   
                continue
            else:
                for image in series:
                    number_of_series += 1
                    final_paths.append(path)
        else:
            print(f&#34;Its not 2 or 3D!:{series}&#34;)
            #TODO: change to exception
            exit(0)
    return number_of_series, final_paths</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_all_slices_from_series"><code class="name flex">
<span>def <span class="ident">load_all_slices_from_series</span></span>(<span>paths, all_series_length, output_shape, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a dataset of 2D slices from a list
of 2 or 3 dimensional scans. Use <code><a title="medpicpy.parsing.get_length_of_all_series" href="#medpicpy.parsing.get_length_of_all_series">get_length_of_all_series()</a></code>
to find <code>all_series_length</code> if it is not known
ahead of time. </p>
<h2 id="args">Args</h2>
<dl>
<dt>paths (list(str)): list of image paths to load</dt>
<dt><strong><code>all_series_length</code></strong> :&ensp;<code>int</code></dt>
<dd>length of output array</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>dimensions to resize each slice to </dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>store data on drive instead of ram. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np Array</code></dt>
<dd>numpy array of resized slices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_all_slices_from_series(paths,
    all_series_length,
    output_shape,
    use_memory_mapping=False):
    &#34;&#34;&#34;Load a dataset of 2D slices from a list 
    of 2 or 3 dimensional scans. Use `get_length_of_all_series`
    to find `all_series_length` if it is not known 
    ahead of time. 

    Args:
        paths (list(str)): list of image paths to load
        all_series_length (int): length of output array
        output_shape (tuple): dimensions to resize each slice to 
        use_memory_mapping (bool, optional): store data on drive instead of ram. Defaults to False.

    Returns:
        np Array: numpy array of resized slices
    &#34;&#34;&#34;
    
    output_array_shape = (all_series_length,) + output_shape
    array = io.allocate_array(output_array_shape, use_memory_mapping=use_memory_mapping)
    images_written = 0
    for image_index, path in enumerate(paths):
        try:
            if images_written == all_series_length:
                print(&#34;Breaking early&#34;)
                break
            if image_index % 100 == 0:
                print(f&#34;Re-loading image: {image_index} of {len(paths)}&#34;, end=&#34;\r&#34;)
                logging.debug(f&#34;Re-loading image: {image_index} of {len(paths)}&#34;)
            
            image = io.load_image(path, use_memory_mapping=use_memory_mapping)
            if image is None:
                continue
            image_shape = image.shape
            if len(image_shape) == 2:
                resized_image = cv2.resize(image, output_shape)
                array[images_written] = resized_image[:]
                images_written += 1
            elif len(image_shape) == 3:

                if image_shape[0] == 1: #its actually 2d
                    resized_image = cv2.resize(image, output_shape)
                    array[images_written] = resized_image[:]
                    images_written += 1
                elif image_shape[2] == 3:
                    continue    #skip rgb
                else:
                    for slice_index in range(len(image)):
                        resized_image = cv2.resize(image[slice_index], output_shape)
                        array[images_written] = resized_image[:]
                        images_written += 1
        except IndexError:
            #TODO: a weird bug, look into why this happens sometimes. 
            if config.suppress_errors:
                logging.debug(f&#34;Suppressing index error in load index for paths:\nAttempted to write to index {images_written}, out of bounds for length {len(array)} on image path {path}&#34;)
            else:
                raise
    return array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_bounding_boxes_from_csv"><code class="name flex">
<span>def <span class="ident">load_bounding_boxes_from_csv</span></span>(<span>dataframe, centre_x_column, centre_y_column, width_column, height_column, x_scale_factor=1, y_scale_factor=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Read bounding boxes from dataframe of csv</p>
<h2 id="example">Example</h2>
<pre><code class="python">import medpicpy as med
import pandas as pd

description = pd.read_csv(&quot;data.csv&quot;) 

# x and y scale factor are new_image_size / original_image_size
# only set if the images were resized when being loaded in
x_scale_factor = 224 / 1024
y_scale_factor = 224 / 1024

xs, ys, widths, heights = med.load_bounding_boxes_from_csv(
    description, 
    4, 
    5, 
    6, 
    6, 
    x_scale_factor=x_scale_factor, 
    y_scale_factor=y_scale_factor
)

</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataframe of csv</dd>
<dt><strong><code>centre_x_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for x anchor or box</dd>
<dt><strong><code>centre_y_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for y anchor of box</dd>
<dt><strong><code>width_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for width of box</dd>
<dt><strong><code>height_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for heigh of box.
Can be same as width column for squares or circles.</dd>
<dt><strong><code>x_scale_factor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Factor to rescale by if image was reshaped. Defaults to 1.</dd>
<dt><strong><code>y_scale_factor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Factor to rescale by if image was reshaped. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>4 tuple of np.Arrays with x, y, widths and heights</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_bounding_boxes_from_csv(
    dataframe, 
    centre_x_column, 
    centre_y_column, 
    width_column, 
    height_column, 
    x_scale_factor=1,
    y_scale_factor=1
    ): # for bounding boxes need to know if measurements are in pixels or mm
    &#34;&#34;&#34;Read bounding boxes from dataframe of csv

    ##Example
    ```python
    import medpicpy as med
    import pandas as pd

    description = pd.read_csv(&#34;data.csv&#34;) 

    # x and y scale factor are new_image_size / original_image_size
    # only set if the images were resized when being loaded in
    x_scale_factor = 224 / 1024
    y_scale_factor = 224 / 1024

    xs, ys, widths, heights = med.load_bounding_boxes_from_csv(
        description, 
        4, 
        5, 
        6, 
        6, 
        x_scale_factor=x_scale_factor, 
        y_scale_factor=y_scale_factor
    )

    ```
    Args:
        dataframe (pandas.DataFrame): Dataframe of csv
        centre_x_column (index): Index of column for x anchor or box
        centre_y_column (index): Index of column for y anchor of box
        width_column (index): Index of column for width of box
        height_column (index): Index of column for heigh of box.
            Can be same as width column for squares or circles.
        x_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.
        y_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.

    Returns:
        tuple: 4 tuple of np.Arrays with x, y, widths and heights
    &#34;&#34;&#34;
    bbox_xs = dataframe[centre_x_column]
    bbox_xs = bbox_xs.multiply(x_scale_factor)
    xs_array = bbox_xs.to_numpy(dtype=np.float16)

    bbox_ys = dataframe[centre_y_column]
    bbox_ys = bbox_ys.multiply(y_scale_factor)
    ys_array = bbox_ys.to_numpy(dtype=np.float16)


    bbox_widths = dataframe[width_column]
    bbox_widths = bbox_widths.multiply(x_scale_factor)
    widths_array = bbox_widths.to_numpy(dtype=np.float16)

    bbox_heights = dataframe[height_column]
    bbox_heights = bbox_heights.multiply(y_scale_factor)
    heights_array = bbox_heights.to_numpy(dtype=np.float16)

    array_tuple = (xs_array, ys_array, widths_array, heights_array)

    return array_tuple</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_classes_in_directory_name"><code class="name flex">
<span>def <span class="ident">load_classes_in_directory_name</span></span>(<span>directory, image_extension, output_shape, class_level=1, slices_to_take=None, slice_axis=-2, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse datasets where the class name is in the
directory structure</p>
<p>Use this when the class name is one of the directory names
in the dataset structure. </p>
<h2 id="example">Example</h2>
<p>If dataset has directory structure:</p>
<pre><code>dataset/
    benign/
        im001.dcm
        im002.dcm
    malignant/
        im001.dcm
        im002.dcm
</code></pre>
<p>then:</p>
<pre><code class="python">    import medpicpy as med

    classes, images = med.load_classes_in_directory_name(
        &quot;dataset/&quot;,
        &quot;.dcm&quot;,
        &quot;(128, 128)&quot;
    )
    print(classes)
    # [&quot;benign&quot;, &quot;benign&quot;, &quot;malignant&quot;, &quot;malignant&quot;]
    print(images.shape)
    # (4, 128, 128)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>path</code></dt>
<dd>root directory of dataset</dd>
<dt><strong><code>image_extension</code></strong> :&ensp;<code>str</code></dt>
<dd>Wildcard for identifying images,
e.g for png's - *.png</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Desired output shape of images</dd>
<dt><strong><code>class_level</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Which level of directory structure
contains class name. Defaults to 1.</dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>optional, boolean</code></dt>
<dd>store the data on disk instead of in memory.
Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list(str), np.Array : list of classes and corresponding images with correct shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_classes_in_directory_name(directory, 
    image_extension, 
    output_shape, 
    class_level=1,
    slices_to_take=None,
    slice_axis=-2,
    use_memory_mapping=False):
    &#34;&#34;&#34;Parse datasets where the class name is in the 
    directory structure

    Use this when the class name is one of the directory names
    in the dataset structure. 
    ## Example
    If dataset has directory structure:
    ```
    dataset/
        benign/
            im001.dcm
            im002.dcm
        malignant/
            im001.dcm
            im002.dcm
    ```
    then:
    ```python
        import medpicpy as med
        
        classes, images = med.load_classes_in_directory_name(
            &#34;dataset/&#34;,
            &#34;.dcm&#34;,
            &#34;(128, 128)&#34;
        )
        print(classes)
        # [&#34;benign&#34;, &#34;benign&#34;, &#34;malignant&#34;, &#34;malignant&#34;]
        print(images.shape)
        # (4, 128, 128)
    ```
    Args:
        directory (path): root directory of dataset
        image_extension (str): Wildcard for identifying images,
             e.g for png&#39;s - *.png
        output_shape (tuple): Desired output shape of images
        class_level (int, optional): Which level of directory structure 
            contains class name. Defaults to 1.
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        list(str), np.Array : list of classes and corresponding images with correct shape
    &#34;&#34;&#34;
    path_to_search = directory + &#34;/**/*&#34; + image_extension
    files = glob.glob(path_to_search, recursive=True)
    files = remove_sub_paths(files)
    number_of_files = len(files)
    array_shape = (number_of_files,) + output_shape
    array = io.allocate_array(array_shape, use_memory_mapping=use_memory_mapping)
    classes = np.empty(number_of_files, dtype=object)

    for index, name in enumerate(files):
        parts = Path(name).parts
        class_name = parts[class_level]

        image = io.load_image(name, use_memory_mapping=use_memory_mapping)
        result = cv2.resize(image, output_shape)

        classes[index] = class_name
        array[index] = result
        
    return classes, array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_images_from_csv"><code class="name flex">
<span>def <span class="ident">load_images_from_csv</span></span>(<span>dataframe, image_name_column, image_dir_path, output_shape, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read in an array of images from paths specified in a csv</p>
<h2 id="example">Example</h2>
<pre><code class="python">import medpicpy as med
import pandas as pd

description = pd.read_csv(&quot;data.csv&quot;) 
array = med.load_images_from_csv(description, 0, &quot;mini-MIAS/&quot;, (224, 224))
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe from the csv</dd>
<dt><strong><code>image_name_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column with image names</dd>
<dt><strong><code>image_dir_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path to directory containing images</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Output shape for each image</dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>optional, boolean</code></dt>
<dd>store the data on disk instead of in memory.
Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.Array</code></dt>
<dd>Array of images in order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_from_csv(dataframe, 
image_name_column, 
image_dir_path, 
output_shape,
use_memory_mapping=False):
    &#34;&#34;&#34;Read in an array of images from paths specified in a csv

    ##Example
    ```python
    import medpicpy as med
    import pandas as pd

    description = pd.read_csv(&#34;data.csv&#34;) 
    array = med.load_images_from_csv(description, 0, &#34;mini-MIAS/&#34;, (224, 224))
    ```
    Args:
        dataframe (pandas.DataFrame): A pandas dataframe from the csv
        image_name_column (index): Index of column with image names
        image_dir_path (string): Path to directory containing images
        output_shape (tuple): Output shape for each image
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False

    Returns:
        np.Array: Array of images in order 
    &#34;&#34;&#34;
    image_names = dataframe[image_name_column]
    image_paths = image_names.apply(lambda x : image_dir_path + &#34;/&#34; + x)
    image_paths = image_paths.apply(lambda x : normpath(x))

    images = load_images_from_paths(image_paths, output_shape, use_memory_mapping=use_memory_mapping)
    return images</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_images_from_paths"><code class="name flex">
<span>def <span class="ident">load_images_from_paths</span></span>(<span>paths, output_shape, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>2D image loading function that takes an array of
paths and an output shape and returns the images in
the same order as the paths. Requires every
path to have an image and every image to be resizeable
to the given output shape.</p>
<p>For higher dimension images use load_series_from_paths.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list</code> or <code>array-like</code></dt>
<dd>paths of images to load</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>desired shape of each image</dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>optional, boolean</code></dt>
<dd>store the data on disk instead of in memory.
Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>all images in numpy format with given shape</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_from_paths(paths, output_shape, use_memory_mapping=False):
    &#34;&#34;&#34;2D image loading function that takes an array of 
    paths and an output shape and returns the images in 
    the same order as the paths. Requires every 
    path to have an image and every image to be resizeable 
    to the given output shape.

    For higher dimension images use load_series_from_paths.

    Args:
        paths (list or array-like): paths of images to load
        output_shape (tuple): desired shape of each image
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        np.array: all images in numpy format with given shape
    &#34;&#34;&#34;
    array_length = len(paths)
    array_shape = (array_length,) + output_shape # concat tuples to get shape
    image_array = io.allocate_array(array_shape, use_memory_mapping=use_memory_mapping)

    for i in range(0, array_length):
        print(&#34;Loading images {} / {}&#34;.format(i + 1, len(paths)), end=&#34;\r&#34;, flush=True)
        image_name = paths[i]
        image = io.load_image(image_name, use_memory_mapping=use_memory_mapping)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized
    print(&#34;&#34;)
    return image_array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_series_from_paths"><code class="name flex">
<span>def <span class="ident">load_series_from_paths</span></span>(<span>paths, slice_output_shape, slices_to_take, slice_axis=-2, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an array of 3D scans into memory from their paths.</p>
<p>Useful for e.g. CT or MR scans. Takes a list of paths, the output shape
for each 2D slice and a list containing which slices
to take from each image. To take the first 60 slices
pass range(0, 60). </p>
<p>The output shape should be a tuple of (int, int).</p>
<p>Optionally take which axis to reshape the image along.
For any scans with one channel (grayscale) slices this should
be -2, if there is a colour channel (or its some kind
of multimodal stack) then the axis would be -3. </p>
<h2 id="example">Example</h2>
<p>If there is dataset with structure:</p>
<pre><code>data/
    patient-data.csv
    ID-001/
        SCANS/
            CT/
                prone.nii.gz
    ID-002/
        SCANS/
            CT/
                prone.nii.gz
    ID-003/
        SCANS/
            CT/
                prone.nii.gz
</code></pre>
<p>then:</p>
<pre><code class="python">import pandas as pd
import medpicpy as med

description = pd.read_csv(&quot;data/patient-data.csv&quot;)
patient_ids = description(&quot;id&quot;)
filters = [&quot;CT&quot;, &quot;prone&quot;]

image_paths = med.get_paths_from_ids(
    &quot;data/&quot;,
    patient_ids,
    filters
)

print(image_paths)
# [&quot;data/ID-001/CT/prone.nii.gz&quot;, &quot;data/ID-002/CT/prone.nii.gz&quot;, &quot;data/ID-003/CT/prone.nii.gz&quot;]

slices_to_take = range(60, 120)
output_slice_shape = (128, 128)    # desired shape of each slice in the scan
images = med.load_series_from_paths(
    paths, 
    output_slice_shape,
    slices_to_take
    )

print(images.shape)
# (3, 60, 128, 128)  
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list</code></dt>
<dd>list of paths to the scans to load</dd>
<dt><strong><code>slice_output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>shape each slice should be resized to</dd>
<dt><strong><code>slices_to_take</code></strong> :&ensp;<code>list</code></dt>
<dd>list of indices of slices to take</dd>
<dt><strong><code>slice_axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>axis to resize along. Defaults to -2.</dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>optional, boolean</code></dt>
<dd>store the data on disk instead of in memory.
Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>array of all scans with specified size</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_series_from_paths(
    paths,
    slice_output_shape, 
    slices_to_take,
    slice_axis=-2,
    use_memory_mapping=False
    ):
    &#34;&#34;&#34;Load an array of 3D scans into memory from their paths.

    Useful for e.g. CT or MR scans. Takes a list of paths, the output shape
    for each 2D slice and a list containing which slices 
    to take from each image. To take the first 60 slices
    pass range(0, 60). 

    The output shape should be a tuple of (int, int).
    
    Optionally take which axis to reshape the image along.
    For any scans with one channel (grayscale) slices this should 
    be -2, if there is a colour channel (or its some kind 
    of multimodal stack) then the axis would be -3. 

    ## Example
    If there is dataset with structure:
    ```
    data/
        patient-data.csv
        ID-001/
            SCANS/
                CT/
                    prone.nii.gz
        ID-002/
            SCANS/
                CT/
                    prone.nii.gz
        ID-003/
            SCANS/
                CT/
                    prone.nii.gz
    ```
    then:
    ```python
    import pandas as pd
    import medpicpy as med

    description = pd.read_csv(&#34;data/patient-data.csv&#34;)
    patient_ids = description(&#34;id&#34;)
    filters = [&#34;CT&#34;, &#34;prone&#34;]

    image_paths = med.get_paths_from_ids(
        &#34;data/&#34;,
        patient_ids,
        filters
    )

    print(image_paths)
    # [&#34;data/ID-001/CT/prone.nii.gz&#34;, &#34;data/ID-002/CT/prone.nii.gz&#34;, &#34;data/ID-003/CT/prone.nii.gz&#34;]
    
    slices_to_take = range(60, 120)
    output_slice_shape = (128, 128)    # desired shape of each slice in the scan
    images = med.load_series_from_paths(
        paths, 
        output_slice_shape,
        slices_to_take
        )

    print(images.shape)
    # (3, 60, 128, 128)  
    ```
    
    Args:
        paths (list): list of paths to the scans to load
        slice_output_shape (tuple): shape each slice should be resized to
        slices_to_take (list): list of indices of slices to take
        slice_axis (int, optional): axis to resize along. Defaults to -2.
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False
    Returns:
        np.array: array of all scans with specified size
    &#34;&#34;&#34;

    output_shape = (len(paths), len(slices_to_take)) + slice_output_shape
    output_array = io.allocate_array(output_shape, use_memory_mapping=use_memory_mapping)
    
    for i in range(0, len(paths)):
        print(&#34;Loading images {} / {}&#34;.format(i + 1, len(paths)), end=&#34;\r&#34;, flush=True)
        path = paths[i]
        image = io.load_image(path, use_memory_mapping=False)
        new_image = io.allocate_array(((len(slices_to_take),) + image[0].shape), use_memory_mapping=False)

        for index, slice_index in enumerate(slices_to_take):
            new_image[index] = image[slice_index]
        
        final_shape = new_image.shape[:slice_axis] + slice_output_shape + new_image.shape[:slice_axis + 2]
        final_image = io.allocate_array(final_shape, use_memory_mapping=use_memory_mapping)

        for j in range(final_shape[0]):
            image = new_image[j][slice_axis]
            image = cv2.resize(image, slice_output_shape)
            final_image[j] = image
        
        output_array[i] = final_image
    print(&#34;&#34;)
    return output_array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_specific_slices_from_series"><code class="name flex">
<span>def <span class="ident">load_specific_slices_from_series</span></span>(<span>paths, output_shape, slices_to_take, use_memory_mapping=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Get specific slice or slices from series of scans.
Takes path, desired shape and array of slice/slices to
take from each series. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>array</code></dt>
<dd>array of paths to the series</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>desired shape of each slice</dd>
<dt><strong><code>slices_to_take</code></strong> :&ensp;<code>array</code> of <code>arrays</code></dt>
<dd>one array of slices
to take for each series</dd>
<dt><strong><code>use_memory_mapping</code></strong> :&ensp;<code>optional, boolean</code></dt>
<dd>store the data on disk instead of in memory.
Defaults to False</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>every slice as specified by the slices_to_take</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_specific_slices_from_series(
    paths,
    output_shape,
    slices_to_take,
    use_memory_mapping=False):
    &#34;&#34;&#34;Get specific slice or slices from series of scans.
    Takes path, desired shape and array of slice/slices to 
    take from each series. 

    Args:
        paths (array): array of paths to the series
        output_shape (tuple): desired shape of each slice
        slices_to_take (array of arrays): one array of slices 
            to take for each series
        use_memory_mapping (optional, boolean): store the data on disk instead of in memory.
            Defaults to False

    Returns:
        np.array: every slice as specified by the slices_to_take
    &#34;&#34;&#34; 
    all_series = [io.load_image(path, use_memory_mapping=use_memory_mapping) for path in paths]
    chosen = [[] for series in all_series]

    if len(all_series) is not len(slices_to_take):
        print(&#34;length of series is not the same as slices array&#34;)
        exit(0)
    
    for series in range(0, len(slices_to_take)):
        for slice_index in slices_to_take[series]:
            chosen_slice = all_series[series][slice_index]
            resized_slice = cv2.resize(chosen_slice, output_shape)
            chosen[series].append(resized_slice)
    
    series_lengths = [len(new_series) for new_series in chosen]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape

    array = io.allocate_array(output_array_shape, use_memory_mapping=use_memory_mapping)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = chosen[series_counter][image_counter]
            output_index += 1
    

    return array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.stack_modalities"><code class="name flex">
<span>def <span class="ident">stack_modalities</span></span>(<span>arrays, axis=-1)</span>
</code></dt>
<dd>
<div class="desc"><p>Turn a list of arrays into one multimodal array.</p>
<p>Creates one array where each element has
len(arrays) images. </p>
<h2 id="example">Example</h2>
<p>If we have a dataset like:</p>
<pre><code>dataset/
    ID-1/
        flair.nii.gz
        t1.nii.gz
    ID-2/
        flair.nii.gz
        t1.nii.gz
</code></pre>
<p>then:</p>
<pre><code class="python">import medpicpy as med 
modalities = [[&quot;flair&quot;], [&quot;t1&quot;]]
paths_for_modality = [med.get_paths_from_ids(
    &quot;dataset/&quot;,
    [&quot;ID-1&quot;, &quot;ID-2&quot;],
    path_filters = modality
) for modality in modalities]

arrays = [med.load_series_from_paths(
    paths,
    (128, 128),
    range(60, 80)
) for paths in paths_for_modality]

multimodal_array = med.stack_modalities(arrays)
print(multimodal_array.shape)
# (259, 20, 128, 128, 4)
</code></pre>
<p>You might want to flatten along the first axis after
doing this depending on the dimensionality of the model you are using.</p>
<pre><code class="python">flat_multi_modal = multimodal_array.reshape(-1, *multimodal_array.shape[2:])
print(&quot;multi modal shape: &quot;, flat_multi_modal.shape)
# (5180, 128, 128, 4)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>arrays</code></strong> :&ensp;<code>array</code></dt>
<dd>array of arrays of images to stack on
top of each other</dd>
<dt><strong><code>axis</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The axis to stack along,
leaving this default is probably fine. Defaults to -1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>array</code></dt>
<dd>the arrays stacked on top of each other</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def stack_modalities(arrays, axis=-1):
    &#34;&#34;&#34;Turn a list of arrays into one multimodal array.
    
    Creates one array where each element has 
    len(arrays) images. 

    ##Example
    If we have a dataset like:
    ```
    dataset/
        ID-1/
            flair.nii.gz
            t1.nii.gz
        ID-2/
            flair.nii.gz
            t1.nii.gz
    ```
    then:
    ```python
    import medpicpy as med 
    modalities = [[&#34;flair&#34;], [&#34;t1&#34;]]
    paths_for_modality = [med.get_paths_from_ids(
        &#34;dataset/&#34;,
        [&#34;ID-1&#34;, &#34;ID-2&#34;],
        path_filters = modality
    ) for modality in modalities]

    arrays = [med.load_series_from_paths(
        paths,
        (128, 128),
        range(60, 80)
    ) for paths in paths_for_modality]

    multimodal_array = med.stack_modalities(arrays)
    print(multimodal_array.shape)
    # (259, 20, 128, 128, 4)
    ```
    You might want to flatten along the first axis after 
    doing this depending on the dimensionality of the model you are using.
    ```python
    flat_multi_modal = multimodal_array.reshape(-1, *multimodal_array.shape[2:])
    print(&#34;multi modal shape: &#34;, flat_multi_modal.shape)
    # (5180, 128, 128, 4)
    ```
    Args:
        arrays (array): array of arrays of images to stack on 
            top of each other
        axis (int, optional): The axis to stack along, 
            leaving this default is probably fine. Defaults to -1.

    Returns:
        array: the arrays stacked on top of each other
    &#34;&#34;&#34;
    return np.stack(arrays, axis=axis)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="medpicpy" href="index.html">medpicpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="medpicpy.parsing.get_length_of_all_series" href="#medpicpy.parsing.get_length_of_all_series">get_length_of_all_series</a></code></li>
<li><code><a title="medpicpy.parsing.load_all_slices_from_series" href="#medpicpy.parsing.load_all_slices_from_series">load_all_slices_from_series</a></code></li>
<li><code><a title="medpicpy.parsing.load_bounding_boxes_from_csv" href="#medpicpy.parsing.load_bounding_boxes_from_csv">load_bounding_boxes_from_csv</a></code></li>
<li><code><a title="medpicpy.parsing.load_classes_in_directory_name" href="#medpicpy.parsing.load_classes_in_directory_name">load_classes_in_directory_name</a></code></li>
<li><code><a title="medpicpy.parsing.load_images_from_csv" href="#medpicpy.parsing.load_images_from_csv">load_images_from_csv</a></code></li>
<li><code><a title="medpicpy.parsing.load_images_from_paths" href="#medpicpy.parsing.load_images_from_paths">load_images_from_paths</a></code></li>
<li><code><a title="medpicpy.parsing.load_series_from_paths" href="#medpicpy.parsing.load_series_from_paths">load_series_from_paths</a></code></li>
<li><code><a title="medpicpy.parsing.load_specific_slices_from_series" href="#medpicpy.parsing.load_specific_slices_from_series">load_specific_slices_from_series</a></code></li>
<li><code><a title="medpicpy.parsing.stack_modalities" href="#medpicpy.parsing.stack_modalities">stack_modalities</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>