<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>medpicpy.parsing API documentation</title>
<meta name="description" content="medpicpy&#39;s higher level functions to abstract over reading
in medical imaging data" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>medpicpy.parsing</code></h1>
</header>
<section id="section-intro">
<p>medpicpy's higher level functions to abstract over reading
in medical imaging data</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;medpicpy&#39;s higher level functions to abstract over reading 
in medical imaging data

&#34;&#34;&#34;
import pandas as pd
import numpy as np
import cv2
import glob
from pathlib import Path

from . import io

# opt args to add
#   - resize keeps aspect ratio?
#TODO: probably change it from taking a dataframe to taking an array (i.e. pd.Series)
def load_images_from_csv(dataframe, image_name_column, image_dir_path, output_shape):
    &#34;&#34;&#34;Read in an array of images from paths specified in a csv

    Args:
        dataframe (pandas.DataFrame): A pandas dataframe from the csv
        image_name_column (index): Index of column with image names
        image_dir_path (string): Path to directory containing images
        output_shape (tuple): Output shape for each image

    Returns:
        np.Array: Array of images in order 
    &#34;&#34;&#34;
    array_length = len(dataframe[image_name_column])
    array_shape = (array_length,) + output_shape    # needs to be a tuple to concatenate
    image_array = np.zeros(array_shape)

    for i in range(0, array_length):
        image_name = dataframe[image_name_column][i]
        image_path = image_dir_path + image_name
        image = io.load_image(image_path)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized

    return image_array
    
    
#TODO kind of useless since they already have the bounding boxes as arrays
def load_bounding_boxes_from_csv(
    dataframe, 
    centre_x_column, 
    centre_y_column, 
    width_column, 
    height_column, 
    x_scale_factor=1,
    y_scale_factor=1
    ): # for bounding boxes need to know if measurements are in pixels or mm
    &#34;&#34;&#34;Read bounding boxes from dataframe of csv

    Args:
        dataframe (pandas.DataFrame): Dataframe of csv
        centre_x_column (index): Index of column for x anchor or box
        centre_y_column (index): Index of column for y anchor of box
        width_column (index): Index of column for width of box
        height_column (index): Index of column for heigh of box.
            Can be same as width column for squares or circles.
        x_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.
        y_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.

    Returns:
        tuple: 4 tuple of np.Arrays with x, y, widths and heights
    &#34;&#34;&#34;
    bbox_xs = dataframe[centre_x_column]
    bbox_xs = bbox_xs.multiply(x_scale_factor)
    xs_array = bbox_xs.to_numpy(dtype=np.float16)

    bbox_ys = dataframe[centre_y_column]
    bbox_ys = bbox_ys.multiply(y_scale_factor)
    ys_array = bbox_ys.to_numpy(dtype=np.float16)


    bbox_widths = dataframe[width_column]
    bbox_widths = bbox_widths.multiply(x_scale_factor)
    widths_array = bbox_widths.to_numpy(dtype=np.float16)

    bbox_heights = dataframe[height_column]
    bbox_heights = bbox_heights.multiply(y_scale_factor)
    heights_array = bbox_heights.to_numpy(dtype=np.float16)

    array_tuple = (xs_array, ys_array, widths_array, heights_array)

    return array_tuple

# To read datasets where the class name is in the directory structure.
# i.e. covid/im001 or no-covid/im001
# pulls the class names from the path and reads in the images
# as a numpy array
def load_classes_in_directory_name(directory, image_file_wildcard, output_shape, class_level=1):
    &#34;&#34;&#34;Parse datasets where the class name is in the 
    directory structure

    Args:
        directory (path): root directory of dataset
        image_file_wildcard (str): Wildcard for identifying images,
             e.g for png&#39;s - *.png
        output_shape (tuple): Desired output shape of images
        class_level (int, optional): Which level of directory structure 
            contains class name. Defaults to 1.

    Returns:
        list(str), np.Array : list of classes and corresponding images with correct shape
    &#34;&#34;&#34;
    path_to_search = directory + &#34;/**/&#34; + image_file_wildcard
    files = glob.glob(path_to_search, recursive=True)

    number_of_files = len(files)
    array_shape = (number_of_files,) + output_shape #concatonate the tuples
    array = np.zeros(array_shape, dtype=np.int16)
    classes = np.empty(number_of_files, dtype=object)

    for index, name in enumerate(files):
        parts = Path(name).parts
        class_name = parts[class_level]

        image = io.load_image(name)
        result = cv2.resize(image, output_shape)

        classes[index] = class_name
        array[index] = result
        
    return classes, array



def load_images_from_paths(paths, output_shape):
    &#34;&#34;&#34;General image loading function that takes an array of 
    paths and an output shape and returns the images in 
    the same order as the paths. Requires every 
    path to have an image and every image to be resizeable 
    to the given output shape

    Args:
        paths (list or array-like): paths of images to load
        output_shape (tuple): desired shape of each image

    Returns:
        np.array: all images in numpy format with given shape
    &#34;&#34;&#34;
    array_length = len(paths)
    array_shape = (array_length,) + output_shape # concat tuples to get shape
    image_array = np.zeros(array_shape)

    for i in range(0, array_length):
        image_name = paths[i]
        image = io.load_image(image_name)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized
    
    return image_array

#output shape is the shape for each image
# TODO: we could also have it return the paths, or image 
# names or something
# get_all_slices_from_scans maybe
def load_all_slices_from_series(paths, output_shape):
    &#34;&#34;&#34;Reads a dataset of 2d images from a 3d series

    Args:
        paths (list or array-like): List of paths to series 
        output_shape (tuple): desired output shape for each slice

    Returns:
        numpy.Array: array containing the reshaped slices
    &#34;&#34;&#34;
    all_series = [io.load_image(path) for path in paths]
    reshaped = [[cv2.resize(image, output_shape) for image in images] for images in all_series]
    series_lengths = [len(series) for series in reshaped]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape
    array = np.zeros(output_array_shape)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = reshaped[series_counter][image_counter]
            output_index += 1
    

    return array

#TODO: for this one we do know the output size ahead of time 
# so we can make this faster
def load_specific_slices_from_series(paths, output_shape, slices_to_take):
    &#34;&#34;&#34;Get specific slice or slices from series of scans.
    Takes path, desired shape and array of slice/slices to 
    take from each series. 

    Args:
        paths (array): array of paths to the series
        output_shape (tuple): desired shape of each slice
        slices_to_take (array of arrays): one array of slices 
            to take for each series

    Returns:
        np.array: every slice as specified by the slices_to_take
    &#34;&#34;&#34; 
    all_series = [io.load_image(path) for path in paths]
    chosen = [[] for series in all_series]

    if len(all_series) is not len(slices_to_take):
        print(&#34;length of series is not the same as slices array&#34;)
        exit(0)
    
    for series in range(0, len(slices_to_take)):
        for slice_index in slices_to_take[series]:
            chosen_slice = all_series[series][slice_index]
            resized_slice = cv2.resize(chosen_slice, output_shape)
            chosen[series].append(resized_slice)
    
    series_lengths = [len(new_series) for new_series in chosen]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape

    #TODO: duplicated code.
    array = np.zeros(output_array_shape)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = chosen[series_counter][image_counter]
            output_index += 1
    

    return array</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="medpicpy.parsing.load_all_slices_from_series"><code class="name flex">
<span>def <span class="ident">load_all_slices_from_series</span></span>(<span>paths, output_shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Reads a dataset of 2d images from a 3d series</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list</code> or <code>array-like</code></dt>
<dd>List of paths to series </dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>desired output shape for each slice</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>numpy.Array</code></dt>
<dd>array containing the reshaped slices</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_all_slices_from_series(paths, output_shape):
    &#34;&#34;&#34;Reads a dataset of 2d images from a 3d series

    Args:
        paths (list or array-like): List of paths to series 
        output_shape (tuple): desired output shape for each slice

    Returns:
        numpy.Array: array containing the reshaped slices
    &#34;&#34;&#34;
    all_series = [io.load_image(path) for path in paths]
    reshaped = [[cv2.resize(image, output_shape) for image in images] for images in all_series]
    series_lengths = [len(series) for series in reshaped]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape
    array = np.zeros(output_array_shape)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = reshaped[series_counter][image_counter]
            output_index += 1
    

    return array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_bounding_boxes_from_csv"><code class="name flex">
<span>def <span class="ident">load_bounding_boxes_from_csv</span></span>(<span>dataframe, centre_x_column, centre_y_column, width_column, height_column, x_scale_factor=1, y_scale_factor=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Read bounding boxes from dataframe of csv</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>Dataframe of csv</dd>
<dt><strong><code>centre_x_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for x anchor or box</dd>
<dt><strong><code>centre_y_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for y anchor of box</dd>
<dt><strong><code>width_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for width of box</dd>
<dt><strong><code>height_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column for heigh of box.
Can be same as width column for squares or circles.</dd>
<dt><strong><code>x_scale_factor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Factor to rescale by if image was reshaped. Defaults to 1.</dd>
<dt><strong><code>y_scale_factor</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Factor to rescale by if image was reshaped. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>tuple</code></dt>
<dd>4 tuple of np.Arrays with x, y, widths and heights</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_bounding_boxes_from_csv(
    dataframe, 
    centre_x_column, 
    centre_y_column, 
    width_column, 
    height_column, 
    x_scale_factor=1,
    y_scale_factor=1
    ): # for bounding boxes need to know if measurements are in pixels or mm
    &#34;&#34;&#34;Read bounding boxes from dataframe of csv

    Args:
        dataframe (pandas.DataFrame): Dataframe of csv
        centre_x_column (index): Index of column for x anchor or box
        centre_y_column (index): Index of column for y anchor of box
        width_column (index): Index of column for width of box
        height_column (index): Index of column for heigh of box.
            Can be same as width column for squares or circles.
        x_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.
        y_scale_factor (int, optional): Factor to rescale by if image was reshaped. Defaults to 1.

    Returns:
        tuple: 4 tuple of np.Arrays with x, y, widths and heights
    &#34;&#34;&#34;
    bbox_xs = dataframe[centre_x_column]
    bbox_xs = bbox_xs.multiply(x_scale_factor)
    xs_array = bbox_xs.to_numpy(dtype=np.float16)

    bbox_ys = dataframe[centre_y_column]
    bbox_ys = bbox_ys.multiply(y_scale_factor)
    ys_array = bbox_ys.to_numpy(dtype=np.float16)


    bbox_widths = dataframe[width_column]
    bbox_widths = bbox_widths.multiply(x_scale_factor)
    widths_array = bbox_widths.to_numpy(dtype=np.float16)

    bbox_heights = dataframe[height_column]
    bbox_heights = bbox_heights.multiply(y_scale_factor)
    heights_array = bbox_heights.to_numpy(dtype=np.float16)

    array_tuple = (xs_array, ys_array, widths_array, heights_array)

    return array_tuple</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_classes_in_directory_name"><code class="name flex">
<span>def <span class="ident">load_classes_in_directory_name</span></span>(<span>directory, image_file_wildcard, output_shape, class_level=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Parse datasets where the class name is in the
directory structure</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>directory</code></strong> :&ensp;<code>path</code></dt>
<dd>root directory of dataset</dd>
<dt><strong><code>image_file_wildcard</code></strong> :&ensp;<code>str</code></dt>
<dd>Wildcard for identifying images,
e.g for png's - *.png</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Desired output shape of images</dd>
<dt><strong><code>class_level</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Which level of directory structure
contains class name. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>list(str), np.Array : list of classes and corresponding images with correct shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_classes_in_directory_name(directory, image_file_wildcard, output_shape, class_level=1):
    &#34;&#34;&#34;Parse datasets where the class name is in the 
    directory structure

    Args:
        directory (path): root directory of dataset
        image_file_wildcard (str): Wildcard for identifying images,
             e.g for png&#39;s - *.png
        output_shape (tuple): Desired output shape of images
        class_level (int, optional): Which level of directory structure 
            contains class name. Defaults to 1.

    Returns:
        list(str), np.Array : list of classes and corresponding images with correct shape
    &#34;&#34;&#34;
    path_to_search = directory + &#34;/**/&#34; + image_file_wildcard
    files = glob.glob(path_to_search, recursive=True)

    number_of_files = len(files)
    array_shape = (number_of_files,) + output_shape #concatonate the tuples
    array = np.zeros(array_shape, dtype=np.int16)
    classes = np.empty(number_of_files, dtype=object)

    for index, name in enumerate(files):
        parts = Path(name).parts
        class_name = parts[class_level]

        image = io.load_image(name)
        result = cv2.resize(image, output_shape)

        classes[index] = class_name
        array[index] = result
        
    return classes, array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_images_from_csv"><code class="name flex">
<span>def <span class="ident">load_images_from_csv</span></span>(<span>dataframe, image_name_column, image_dir_path, output_shape)</span>
</code></dt>
<dd>
<div class="desc"><p>Read in an array of images from paths specified in a csv</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dataframe</code></strong> :&ensp;<code>pandas.DataFrame</code></dt>
<dd>A pandas dataframe from the csv</dd>
<dt><strong><code>image_name_column</code></strong> :&ensp;<code>index</code></dt>
<dd>Index of column with image names</dd>
<dt><strong><code>image_dir_path</code></strong> :&ensp;<code>string</code></dt>
<dd>Path to directory containing images</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>Output shape for each image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.Array</code></dt>
<dd>Array of images in order</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_from_csv(dataframe, image_name_column, image_dir_path, output_shape):
    &#34;&#34;&#34;Read in an array of images from paths specified in a csv

    Args:
        dataframe (pandas.DataFrame): A pandas dataframe from the csv
        image_name_column (index): Index of column with image names
        image_dir_path (string): Path to directory containing images
        output_shape (tuple): Output shape for each image

    Returns:
        np.Array: Array of images in order 
    &#34;&#34;&#34;
    array_length = len(dataframe[image_name_column])
    array_shape = (array_length,) + output_shape    # needs to be a tuple to concatenate
    image_array = np.zeros(array_shape)

    for i in range(0, array_length):
        image_name = dataframe[image_name_column][i]
        image_path = image_dir_path + image_name
        image = io.load_image(image_path)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized

    return image_array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_images_from_paths"><code class="name flex">
<span>def <span class="ident">load_images_from_paths</span></span>(<span>paths, output_shape)</span>
</code></dt>
<dd>
<div class="desc"><p>General image loading function that takes an array of
paths and an output shape and returns the images in
the same order as the paths. Requires every
path to have an image and every image to be resizeable
to the given output shape</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>list</code> or <code>array-like</code></dt>
<dd>paths of images to load</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>desired shape of each image</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>all images in numpy format with given shape</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_images_from_paths(paths, output_shape):
    &#34;&#34;&#34;General image loading function that takes an array of 
    paths and an output shape and returns the images in 
    the same order as the paths. Requires every 
    path to have an image and every image to be resizeable 
    to the given output shape

    Args:
        paths (list or array-like): paths of images to load
        output_shape (tuple): desired shape of each image

    Returns:
        np.array: all images in numpy format with given shape
    &#34;&#34;&#34;
    array_length = len(paths)
    array_shape = (array_length,) + output_shape # concat tuples to get shape
    image_array = np.zeros(array_shape)

    for i in range(0, array_length):
        image_name = paths[i]
        image = io.load_image(image_name)
        resized = cv2.resize(image, output_shape)
        image_array[i] = resized
    
    return image_array</code></pre>
</details>
</dd>
<dt id="medpicpy.parsing.load_specific_slices_from_series"><code class="name flex">
<span>def <span class="ident">load_specific_slices_from_series</span></span>(<span>paths, output_shape, slices_to_take)</span>
</code></dt>
<dd>
<div class="desc"><p>Get specific slice or slices from series of scans.
Takes path, desired shape and array of slice/slices to
take from each series. </p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>paths</code></strong> :&ensp;<code>array</code></dt>
<dd>array of paths to the series</dd>
<dt><strong><code>output_shape</code></strong> :&ensp;<code>tuple</code></dt>
<dd>desired shape of each slice</dd>
<dt><strong><code>slices_to_take</code></strong> :&ensp;<code>array</code> of <code>arrays</code></dt>
<dd>one array of slices
to take for each series</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>np.array</code></dt>
<dd>every slice as specified by the slices_to_take</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_specific_slices_from_series(paths, output_shape, slices_to_take):
    &#34;&#34;&#34;Get specific slice or slices from series of scans.
    Takes path, desired shape and array of slice/slices to 
    take from each series. 

    Args:
        paths (array): array of paths to the series
        output_shape (tuple): desired shape of each slice
        slices_to_take (array of arrays): one array of slices 
            to take for each series

    Returns:
        np.array: every slice as specified by the slices_to_take
    &#34;&#34;&#34; 
    all_series = [io.load_image(path) for path in paths]
    chosen = [[] for series in all_series]

    if len(all_series) is not len(slices_to_take):
        print(&#34;length of series is not the same as slices array&#34;)
        exit(0)
    
    for series in range(0, len(slices_to_take)):
        for slice_index in slices_to_take[series]:
            chosen_slice = all_series[series][slice_index]
            resized_slice = cv2.resize(chosen_slice, output_shape)
            chosen[series].append(resized_slice)
    
    series_lengths = [len(new_series) for new_series in chosen]
    output_array_length = sum(series_lengths)
    output_array_shape = (output_array_length,) + output_shape

    #TODO: duplicated code.
    array = np.zeros(output_array_shape)

    output_index = 0
    for series_counter in range(0, len(series_lengths)):
        for image_counter in range(0, series_lengths[series_counter]):
            array[output_index] = chosen[series_counter][image_counter]
            output_index += 1
    

    return array</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="medpicpy" href="index.html">medpicpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="medpicpy.parsing.load_all_slices_from_series" href="#medpicpy.parsing.load_all_slices_from_series">load_all_slices_from_series</a></code></li>
<li><code><a title="medpicpy.parsing.load_bounding_boxes_from_csv" href="#medpicpy.parsing.load_bounding_boxes_from_csv">load_bounding_boxes_from_csv</a></code></li>
<li><code><a title="medpicpy.parsing.load_classes_in_directory_name" href="#medpicpy.parsing.load_classes_in_directory_name">load_classes_in_directory_name</a></code></li>
<li><code><a title="medpicpy.parsing.load_images_from_csv" href="#medpicpy.parsing.load_images_from_csv">load_images_from_csv</a></code></li>
<li><code><a title="medpicpy.parsing.load_images_from_paths" href="#medpicpy.parsing.load_images_from_paths">load_images_from_paths</a></code></li>
<li><code><a title="medpicpy.parsing.load_specific_slices_from_series" href="#medpicpy.parsing.load_specific_slices_from_series">load_specific_slices_from_series</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>